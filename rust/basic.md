# 基础

## 定义变量：补充

之前我对重复 let 一个变量的解释是：隐藏了之前的定义，这里说的清楚点：第一个变量被第二个变量隐藏（shallow）了，我们随后使用这个变量，它会指向到第二个变量，我们可以重复使用 let 关键字来不断地隐藏变量。

隐藏机制允许我们复用简单的名字，而不用我们定义这样的变量：`var_number` 、`var_string` 云云，而在使用 mut 的时候没有这个效果。

还有个 const 关键字，可以在程序的任意位置定义，一般来讲我们会这样定义全局变量，格式一般都是约定俗成的全大写，中间用下划线，比如 `APP_NAME` 这种。

## 数据类型：补充

之前提了基本类型，那肯定也有复合类型。Rust 提供了两种常见复合类型，元组和数组。

### 元组

跟 Python 的元组大同小异吧，就是一个随便装任意类型任意数量的集合，简单演示一下：

```rust
// 这里的类型注解可以省略
let tup: (i32, f64, u8) = (500, 6.4, 1);
// 支持解构赋值
let (x, y, z) = tup;
```

不同于大部分 c-like syntax 的语言，Rust 的元组访问下标不是用形如 `[0]` 的语法，而是用点号：

```rust
println!("{}", tup.1)
```

### 数组

数组跟其他语言大同小异，相同类型，固定长度：

```rust
let arr: [i32; 3] = [1, 2, 3];
println!("{}", arr[0]);
```

## 函数

Rust 的函数遵循蛇形命名法，使用形如 `snake_func` 风格对函数命名。Rust 对函数在哪里定义并不关心，只要定义的地方对调用的地方可见就行。参数必须显式声明类型，这样编译器能为你做更多事。简单来个示例：

```rust
fn five() -> i32 {
    5
}
```

### 表达式与语句

Rust 是一门基于表达式的语言，因此在其他语言中分的不甚清楚的语句和表达式在 Rust 里被严格定义：

> 语句：指执行但不返回值的指令，而表达式则是进行计算并产生一个值作为结果。

最简单的区分就是这样：

```rust
fn main() {
    let x = (let x = 6)
}
```

这样的代码肯定是过不了编译的，因为你不能把语句赋值给变量。

Rust 中的表达式不允许后面加分号，否则会编译错误。

### 函数的返回值

你可以用 return 来显式声明返回值，但是函数默认会返回最后一个表达式，但是如果是在函数中间，比如某次 if 语句判断之后想要返回值，就必须 return，就像这样：

```rust
fn main() {
    fn test(param: i32) -> i32 {
        if param >= 5 {
            return 10;
        }
        5
    }
    let a = test(5);
    println!("{}", a)
}
```

## 控制流

if 的条件不用加括号啥的，if-else 跟其他 c-like syntax 差不多。

```rust
if number < 5 {
    println!("<5");
} else {
    println!(">=5");
}
```

let 语句支持后面跟着 if 语句，就像二元表达式一样；

```rust
let number = if condition { 5 } else { 10 };
```

## 循环

提供三种循环：loop、while、for。

### loop

之前提过了，如果不显式的 break，这个 loop 就是无限循环，或者说等价于 js 中的 `while(true)`。

通常用于反复尝试一些可能失败的操作，比如检查线程是否完成了其工作，不过值得一提的是，你甚至可以在 break 后使用表达式来返回值。

### while

这个就跟其他语言的没啥区别了，唯一区别就是不用加括号。

### for

好像不支持 `for(let i = 1; i<= 10; i++)` 这种，只支持遍历一个可遍历对象。

```rust
let array: [i32; 5] = [10, 20, 30, 40, 50];
for item in array.iter() {
    println!("{}", item)
}
```
